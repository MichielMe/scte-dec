"""
HTML Generator module for creating a visual viewer of extracted frames.

This module generates an HTML, CSS, and JavaScript viewer for the extracted
frames from MXF files, showing SCTE-104 information in a nicely organized way.
"""

import json
import logging
import os
import re
import shutil
from pathlib import Path
from typing import Any, Dict, List, Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCTE-104 Frame Viewer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>SCTE-104 Frame Viewer</h1>
        <div class="file-info">
            <span>File: {filename}</span>
            <span>Total Frames: {total_frames}</span>
        </div>
        <div class="controls">
            <button id="toggle-announcement">Toggle Announcement Frames</button>
            <button id="toggle-scte">Toggle SCTE Trigger Frames</button>
            <button id="toggle-padding">Toggle Padding Frames</button>
            <select id="sort-order">
                <option value="asc">Sort Ascending</option>
                <option value="desc">Sort Descending</option>
            </select>
        </div>
    </header>
    
    <main>
        <div class="frame-container" id="frame-container">
            {frame_items}
        </div>
    </main>
    
    <footer>
        <p>Generated by SCTE Decoder</p>
    </footer>
    
    <script src="viewer.js"></script>
</body>
</html>
"""

CSS_TEMPLATE = """/* Reset and base styles */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f8f9fa;
    padding: 20px;
}

header {
    background: linear-gradient(135deg, #0056b3 0%, #007bff 100%);
    color: white;
    padding: 25px;
    margin-bottom: 40px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
}

h1 {
    margin-bottom: 15px;
    font-size: 2.4rem;
    letter-spacing: -0.5px;
}

.file-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
    font-size: 1.1rem;
    opacity: 0.9;
}

.controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

button, select {
    padding: 12px 18px;
    background: linear-gradient(to bottom, #007bff 0%, #0069d9 100%);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 500;
    transition: all 0.3s;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

button:hover, select:hover {
    background: linear-gradient(to bottom, #0069d9 0%, #0056b3 100%);
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

select {
    background: linear-gradient(to bottom, #5a6268 0%, #495057 100%);
}

.frame-container {
    display: flex;
    flex-direction: column;
    gap: 50px;
}

.timeline-section {
    margin-bottom: 50px;
    transition: all 0.3s;
}

.timeline-label {
    font-weight: 600;
    margin-bottom: 15px;
    font-size: 1.4rem;
    color: #0056b3;
    padding: 12px 20px;
    background-color: white;
    border-radius: 8px 8px 0 0;
    border-bottom: 3px solid #dee2e6;
    transition: all 0.3s;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
}

.timeline-row {
    display: flex;
    gap: 25px;
    padding: 30px;
    background-color: white;
    border-radius: 0 0 8px 8px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
    overflow-x: auto;
    transition: all 0.3s;
}

.timeline-row.announcement-row {
    border-top: 6px solid #ffc107;
}

.timeline-row.scte-row {
    border-top: 6px solid #dc3545;
}

.frame-item {
    background-color: white;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
    transition: transform 0.3s, box-shadow 0.3s;
    min-width: 280px;
    max-width: 330px;
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
}

.frame-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 0.8rem;
    font-weight: bold;
    z-index: 2;
}

.frame-item:hover {
    transform: translateY(-8px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
    z-index: 2;
}

.frame-item.announcement-frame {
    border-top: 5px solid #ffc107;
}

.frame-item.scte-trigger {
    border-top: 5px solid #dc3545;
}

.frame-item.padding-frame {
    border-top: 5px solid #6c757d;
    opacity: 0.85;
}

.frame-item.padding-frame:hover {
    opacity: 1;
}

.hidden {
    display: none !important;
}

.frame-image {
    width: 100%;
    height: 200px;
    object-fit: cover;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: all 0.3s;
}

.frame-image:hover {
    filter: brightness(1.1);
}

.frame-info {
    padding: 22px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    background: linear-gradient(to bottom, #ffffff 0%, #f8f9fa 100%);
}

.frame-number {
    font-weight: bold;
    font-size: 1.3rem;
    margin-bottom: 12px;
    color: #343a40;
}

.frame-type {
    display: inline-block;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    margin-bottom: 18px;
    font-weight: 600;
    letter-spacing: 0.3px;
}

.announcement-type {
    background-color: #fff3cd;
    color: #856404;
    border-left: 3px solid #ffc107;
}

.scte-trigger-type {
    background-color: #f8d7da;
    color: #721c24;
    border-left: 3px solid #dc3545;
}

.padding-type {
    background-color: #e2e3e5;
    color: #383d41;
    border-left: 3px solid #6c757d;
}

.frame-details {
    font-size: 0.95rem;
    line-height: 1.7;
    flex-grow: 1;
    color: #495057;
}

.frame-details p {
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px dotted #e9ecef;
}

.frame-details p:last-child {
    border-bottom: none;
}

.frame-details strong {
    font-weight: 600;
    color: #495057;
    margin-right: 5px;
}

.error-message {
    background-color: #f8d7da;
    color: #721c24;
    padding: 30px;
    border-radius: 8px;
    margin: 30px 0;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.error-message h2 {
    margin-bottom: 15px;
    font-size: 1.8rem;
}

.error-message ul {
    text-align: left;
    max-width: 600px;
    margin: 15px auto;
    padding-left: 40px;
}

.error-message li {
    margin-bottom: 10px;
}

#fallback-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
}

footer {
    margin-top: 80px;
    text-align: center;
    color: #6c757d;
    font-size: 1rem;
    padding: 30px 0;
    border-top: 1px solid #dee2e6;
}

@media (max-width: 768px) {
    .controls {
        flex-direction: column;
    }
    
    button, select {
        width: 100%;
    }
    
    .timeline-row {
        flex-direction: column;
        align-items: center;
    }
    
    .frame-item {
        width: 100%;
        max-width: 100%;
    }
}

/* Modal for enlarged image */
.modal {
    display: none;
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.92);
    justify-content: center;
    align-items: center;
    transition: all 0.3s;
}

.modal-content {
    display: block;
    max-width: 92%;
    max-height: 92%;
    border-radius: 5px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
    transition: all 0.3s;
    opacity: 0;
    transform: scale(0.95);
}

.modal.show .modal-content {
    opacity: 1;
    transform: scale(1);
}

.close {
    position: absolute;
    top: 20px;
    right: 35px;
    color: #f1f1f1;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
    transition: 0.3s;
    z-index: 110;
}

.close:hover {
    color: #bbb;
    text-decoration: none;
    transform: rotate(90deg);
}
"""

JS_TEMPLATE = """document.addEventListener('DOMContentLoaded', function() {
    // Get DOM elements
    const frameContainer = document.getElementById('frame-container');
    const toggleAnnouncementBtn = document.getElementById('toggle-announcement');
    const toggleScteBtn = document.getElementById('toggle-scte');
    const togglePaddingBtn = document.getElementById('toggle-padding');
    const sortOrderSelect = document.getElementById('sort-order');
    
    // Store all frame elements and rows
    const allFrames = Array.from(document.querySelectorAll('.frame-item'));
    const timelineRows = Array.from(document.querySelectorAll('.timeline-row'));
    
    // Create modal for image enlargement
    const modal = document.createElement('div');
    modal.className = 'modal';
    const modalImg = document.createElement('img');
    modalImg.className = 'modal-content';
    const closeBtn = document.createElement('span');
    closeBtn.className = 'close';
    closeBtn.innerHTML = '&times;';
    
    modal.appendChild(closeBtn);
    modal.appendChild(modalImg);
    document.body.appendChild(modal);
    
    // Add click event to all images
    document.querySelectorAll('.frame-image').forEach(img => {
        img.addEventListener('click', function() {
            modal.style.display = 'flex';
            modalImg.src = this.src;
            
            // Add animation class after a small delay to trigger transition
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
        });
    });
    
    // Close modal when clicking the close button
    closeBtn.addEventListener('click', function() {
        modal.classList.remove('show');
        
        // Wait for animation to complete before hiding
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    });
    
    // Close modal when clicking outside the image
    modal.addEventListener('click', function(event) {
        if (event.target === modal) {
            modal.classList.remove('show');
            
            // Wait for animation to complete before hiding
            setTimeout(() => {
                modal.style.display = 'none';
            }, 300);
        }
    });
    
    // Toggle visibility of frame types
    if (toggleAnnouncementBtn) {
        toggleAnnouncementBtn.addEventListener('click', function() {
            document.querySelectorAll('.timeline-row.announcement-row').forEach(row => {
                const label = row.previousElementSibling;
                
                // Apply slide animation
                if (!row.classList.contains('hidden')) {
                    row.style.maxHeight = row.scrollHeight + 'px';
                    setTimeout(() => {
                        row.style.maxHeight = '0';
                        row.style.padding = '0';
                        row.style.opacity = '0';
                        
                        // After animation completes, add hidden class
                        setTimeout(() => {
                            row.classList.add('hidden');
                            if (label && label.classList.contains('timeline-label')) {
                                label.classList.add('hidden');
                            }
                        }, 300);
                    }, 10);
                } else {
                    row.classList.remove('hidden');
                    if (label && label.classList.contains('timeline-label')) {
                        label.classList.remove('hidden');
                    }
                    
                    row.style.maxHeight = '0';
                    row.style.padding = '0';
                    row.style.opacity = '0';
                    
                    // Trigger animation
                    setTimeout(() => {
                        row.style.maxHeight = row.scrollHeight + 'px';
                        row.style.padding = '30px';
                        row.style.opacity = '1';
                    }, 10);
                }
            });
        });
    }
    
    if (toggleScteBtn) {
        toggleScteBtn.addEventListener('click', function() {
            document.querySelectorAll('.timeline-row.scte-row').forEach(row => {
                const label = row.previousElementSibling;
                
                // Apply slide animation
                if (!row.classList.contains('hidden')) {
                    row.style.maxHeight = row.scrollHeight + 'px';
                    setTimeout(() => {
                        row.style.maxHeight = '0';
                        row.style.padding = '0';
                        row.style.opacity = '0';
                        
                        // After animation completes, add hidden class
                        setTimeout(() => {
                            row.classList.add('hidden');
                            if (label && label.classList.contains('timeline-label')) {
                                label.classList.add('hidden');
                            }
                        }, 300);
                    }, 10);
                } else {
                    row.classList.remove('hidden');
                    if (label && label.classList.contains('timeline-label')) {
                        label.classList.remove('hidden');
                    }
                    
                    row.style.maxHeight = '0';
                    row.style.padding = '0';
                    row.style.opacity = '0';
                    
                    // Trigger animation
                    setTimeout(() => {
                        row.style.maxHeight = row.scrollHeight + 'px';
                        row.style.padding = '30px';
                        row.style.opacity = '1';
                    }, 10);
                }
            });
        });
    }
    
    if (togglePaddingBtn) {
        togglePaddingBtn.addEventListener('click', function() {
            document.querySelectorAll('.frame-item.padding-frame').forEach(frame => {
                if (!frame.classList.contains('hidden')) {
                    // Animate out
                    frame.style.opacity = '0.85';
                    frame.style.transform = 'scale(0.95)';
                    
                    setTimeout(() => {
                        frame.classList.add('hidden');
                    }, 300);
                } else {
                    // Animate in
                    frame.classList.remove('hidden');
                    frame.style.opacity = '0';
                    frame.style.transform = 'scale(0.9)';
                    
                    setTimeout(() => {
                        frame.style.opacity = '0.85';
                        frame.style.transform = 'scale(1)';
                    }, 10);
                }
            });
        });
    }
    
    // Sort rows by frame number of the event frame
    if (sortOrderSelect) {
        sortOrderSelect.addEventListener('change', function() {
            const sortOrder = this.value;
            
            // Group rows and their labels
            const rowGroups = [];
            let i = 0;
            while (i < frameContainer.children.length) {
                const label = frameContainer.children[i];
                const row = i + 1 < frameContainer.children.length ? frameContainer.children[i + 1] : null;
                
                if (label && row && label.classList.contains('timeline-label') && row.classList.contains('timeline-row')) {
                    // Extract frame number from the label text
                    const frameMatch = label.textContent.match(/Frame (\d+)/);
                    const frameNumber = frameMatch ? parseInt(frameMatch[1]) : 0;
                    
                    rowGroups.push({ label, row, frameNumber });
                    i += 2;
                } else {
                    i++;
                }
            }
            
            // Sort the row groups
            rowGroups.sort((a, b) => {
                if (sortOrder === 'asc') {
                    return a.frameNumber - b.frameNumber;
                } else {
                    return b.frameNumber - a.frameNumber;
                }
            });
            
            // Animation: fade out all rows first
            rowGroups.forEach(group => {
                group.row.style.opacity = '0';
                group.label.style.opacity = '0';
                group.row.style.transform = 'translateY(-10px)';
                group.label.style.transform = 'translateY(-10px)';
            });
            
            // Wait for fade out, then reorder
            setTimeout(() => {
                // Remove all rows and labels
                rowGroups.forEach(group => {
                    group.label.remove();
                    group.row.remove();
                });
                
                // Re-append in sorted order
                rowGroups.forEach(group => {
                    frameContainer.appendChild(group.label);
                    frameContainer.appendChild(group.row);
                });
                
                // Animation: fade in rows in new order
                setTimeout(() => {
                    rowGroups.forEach(group => {
                        group.row.style.opacity = '1';
                        group.label.style.opacity = '1';
                        group.row.style.transform = 'translateY(0)';
                        group.label.style.transform = 'translateY(0)';
                    });
                }, 10);
            }, 300);
        });
    }
    
    // Add transition styles dynamically
    const style = document.createElement('style');
    style.textContent = `
        .timeline-row {
            transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }
        .timeline-label {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .frame-item {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
    `;
    document.head.appendChild(style);
    
    // Log debug info
    console.log('Total frames:', allFrames.length);
    console.log('Timeline rows:', timelineRows.length);
});
"""


def generate_frame_html_item(frame_path: Path, frame_data: Dict[str, Any]) -> str:
    """
    Generate HTML for a single frame item.

    Args:
        frame_path: Path to the frame image
        frame_data: Frame metadata

    Returns:
        str: HTML for the frame item
    """
    frame_number = frame_data["frame_number"]
    frame_type = frame_data.get("type", "Unknown")
    is_padding = frame_data.get("is_padding", False)
    padding_for = frame_data.get("padding_for", None)

    # Determine CSS class based on frame type
    frame_class = ""
    type_class = ""

    if "Announcement Frame" in frame_type:
        frame_class = "announcement-frame"
        type_class = "announcement-type"
        display_type = "Announcement"
    elif "SCTE Trigger" in frame_type:
        frame_class = "scte-trigger"
        type_class = "scte-trigger-type"
        display_type = "SCTE Trigger"
    else:
        frame_class = "padding-frame"
        type_class = "padding-type"
        display_type = "Padding"

    # Format additional info
    info_html = ""

    # For padding frames, show which event they're associated with
    if is_padding and padding_for is not None:
        info_html += f"<p><strong>Padding for:</strong> Frame {padding_for}</p>"
        info_html += (
            f"<p><strong>Offset:</strong> {frame_number - padding_for} frames</p>"
        )

    # Add SCTE data if available
    if "scte_data" in frame_data:
        scte_data = frame_data["scte_data"]

        # Get segmentation type name safely
        segmentation_type = "Unknown"
        if "segmentation_type" in scte_data:
            if (
                isinstance(scte_data["segmentation_type"], dict)
                and "name" in scte_data["segmentation_type"]
            ):
                segmentation_type = scte_data["segmentation_type"]["name"]
            else:
                segmentation_type = str(scte_data["segmentation_type"])

        # Add SCTE data fields, checking for existence and handling safely
        info_html += f"<p><strong>Event Timestamp:</strong> {scte_data.get('event_timestamp', 'N/A')}</p>"
        info_html += f"<p><strong>Pre-roll Time:</strong> {scte_data.get('pre_roll_time', 'N/A')} ms</p>"
        info_html += f"<p><strong>Event ID:</strong> {scte_data.get('segmentation_event_id', 'N/A')}</p>"
        info_html += f"<p><strong>Duration:</strong> {scte_data.get('duration', 'N/A')} seconds</p>"
        info_html += f"<p><strong>Type:</strong> {segmentation_type}</p>"

    # If no specific info was added, at least show the frame number and type
    if not info_html:
        info_html = f"<p><strong>Frame Number:</strong> {frame_number}</p>"
        if padding_for is not None:
            info_html += f"<p><strong>Related to:</strong> Frame {padding_for}</p>"

    # Build the HTML
    html = f"""
    <div class="frame-item {frame_class}" data-frame-number="{frame_number}">
        <div class="frame-badge">{display_type}</div>
        <img src="{frame_path.name}" alt="Frame {frame_number}" class="frame-image">
        <div class="frame-info">
            <div class="frame-number">Frame {frame_number}</div>
            <span class="frame-type {type_class}">{frame_type}</span>
            <div class="frame-details">
                {info_html}
            </div>
        </div>
    </div>
    """

    return html


def generate_html_viewer(results_dir: Path, input_file: str) -> None:
    """
    Generate an HTML viewer for the extracted frames.

    Args:
        results_dir: Directory containing the results
        input_file: Path to the input MXF file
    """
    logger.info(f"Generating HTML viewer in {results_dir}")

    # Check if metadata.json exists
    metadata_file = results_dir / "metadata.json"
    if not metadata_file.exists():
        logger.warning(f"No metadata.json found in {results_dir}")
        logger.info("Generating basic HTML viewer without metadata")
        return generate_basic_html_viewer(results_dir, input_file)

    # Load metadata
    try:
        with open(metadata_file, "r", encoding="utf-8") as f:
            metadata = json.load(f)
            logger.info(f"Loaded metadata.json successfully")
    except (json.JSONDecodeError, UnicodeDecodeError) as e:
        logger.error(f"Error loading metadata.json: {e}")
        logger.info("Generating basic HTML viewer without metadata")
        return generate_basic_html_viewer(results_dir, input_file)

    # Check for empty metadata
    if not metadata or "frames" not in metadata or not metadata["frames"]:
        logger.warning("Metadata exists but contains no frame data")
        return generate_basic_html_viewer(results_dir, input_file)

    # Get all frame images by mapping frame number to file
    frame_files = {}
    for file_path in results_dir.glob("frames*.jpg"):
        match = re.match(r"frames(\d+)\.jpg", file_path.name)
        if match:
            frame_number = int(match.group(1))
            frame_files[frame_number] = file_path

    if not frame_files:
        logger.warning(f"No frame files found in {results_dir}")
        return

    logger.info(f"Found {len(frame_files)} frame image files")
    logger.info(f"Frame numbers (from files): {sorted(list(frame_files.keys()))}")

    # Get frame mapping if available
    frame_mapping = metadata.get("frame_mapping", {})
    if frame_mapping:
        # Convert keys to strings since JSON serializes dict keys as strings
        frame_mapping = {int(k): int(v) for k, v in frame_mapping.items()}
        logger.info(f"Using frame mapping: {frame_mapping}")

        # Map the frame files to the original frame numbers
        mapped_frame_files = {}
        for output_num, file_path in frame_files.items():
            if str(output_num) in frame_mapping:
                original_num = frame_mapping[str(output_num)]
                mapped_frame_files[original_num] = file_path
            else:
                # Keep the original if not in mapping
                mapped_frame_files[output_num] = file_path

        # If we have a mapping, use the mapped files
        if mapped_frame_files:
            logger.info(
                f"Using mapped frame files: {sorted(list(mapped_frame_files.keys()))}"
            )
            frame_files = mapped_frame_files

    # Check if we have the improved metadata format with frame_groups
    if "frame_groups" in metadata:
        logger.info(
            f"Using improved metadata format with {len(metadata['frame_groups'])} frame groups"
        )
        frame_items_html = generate_grouped_frame_html(metadata, frame_files)
    else:
        # Fall back to the old format - this should not happen with updated code
        logger.warning(
            "Using legacy metadata format - this should not happen with updated code"
        )
        frame_items_html = generate_legacy_frame_html(metadata, frame_files)

    # If we still have no frames, try the fallback method
    if not frame_items_html or frame_items_html.strip() == "":
        logger.warning(
            "No frames were generated with the standard method, trying fallback method"
        )
        frame_items_html = generate_fallback_frame_html(results_dir, frame_files)

    # Generate the HTML content
    html_content = HTML_TEMPLATE.format(
        filename=Path(input_file).name,
        total_frames=len(frame_files),
        frame_items=frame_items_html,
    )

    # Write HTML, CSS, and JS files
    try:
        with open(results_dir / "index.html", "w") as f:
            f.write(html_content)

        with open(results_dir / "styles.css", "w") as f:
            f.write(CSS_TEMPLATE)

        with open(results_dir / "viewer.js", "w") as f:
            f.write(JS_TEMPLATE)

        logger.info(f"HTML viewer generated in {results_dir}")
    except Exception as e:
        logger.error(f"Error writing HTML files: {e}")


def generate_fallback_frame_html(
    results_dir: Path, frame_files: Dict[int, Path]
) -> str:
    """
    Generate a simple HTML that just displays all frames in sequence.

    This is a fallback method when metadata parsing fails.

    Args:
        results_dir: Directory containing the results
        frame_files: Dictionary mapping frame numbers to file paths

    Returns:
        str: HTML content for the frame container
    """
    frame_numbers = sorted(list(frame_files.keys()))
    logger.info(f"Fallback method: displaying {len(frame_numbers)} frames in sequence")

    # Try to load frame_mapping.json if it exists
    frame_mapping_file = results_dir / "frame_mapping.json"
    reverse_mapping = {}
    if frame_mapping_file.exists():
        try:
            with open(frame_mapping_file, "r") as f:
                frame_mapping = json.load(f)
                # Create a reverse mapping from original frame number to output number
                for output_num, original_num in frame_mapping.items():
                    reverse_mapping[int(original_num)] = int(output_num)
                logger.info(f"Loaded frame mapping from {frame_mapping_file}")
        except Exception as e:
            logger.error(f"Error loading frame mapping: {e}")

    html = ""

    # Group frames by 5 for display purposes
    for i in range(0, len(frame_numbers), 5):
        group = frame_numbers[i : i + 5]

        # Determine if this is likely an announcement or SCTE group
        label = f"Frames {group[0]}-{group[-1]}"
        if reverse_mapping:
            # Show the original frame numbers if we have mapping
            original_frames = [reverse_mapping.get(num, num) for num in group]
            label = f"Original Frames {min(original_frames)}-{max(original_frames)}"

        row_type = "announcement-row" if i % 2 == 0 else "scte-row"

        html += f'<div class="timeline-section">\n'
        html += f'<div class="timeline-label">Frame Group {i//5 + 1} ({label})</div>\n'
        html += f'<div class="timeline-row {row_type}">\n'

        for frame_num in group:
            # Get original frame number if available
            display_num = reverse_mapping.get(frame_num, frame_num)

            # Create a simple frame item
            frame_data = {
                "frame_number": display_num,
                "type": "Frame",
                "is_padding": False,
            }

            html += generate_frame_html_item(frame_files[frame_num], frame_data)

        html += "</div>\n"
        html += "</div>\n"

    return html


def generate_grouped_frame_html(
    metadata: Dict[str, Any], frame_files: Dict[int, Path]
) -> str:
    """
    Generate HTML for frames using the improved grouped format.

    Args:
        metadata: Metadata containing frame groups
        frame_files: Dictionary mapping frame numbers to file paths

    Returns:
        str: HTML content for the frame container
    """
    frame_items_html = ""

    # Log information about frame files and metadata
    logger.info(f"Available frame files: {sorted(list(frame_files.keys()))}")
    logger.info(
        f"Number of frame groups in metadata: {len(metadata.get('frame_groups', []))}"
    )

    # Check for frame mapping
    frame_mapping = metadata.get("frame_mapping", {})
    reverse_mapping = {}
    if frame_mapping:
        # Convert keys from strings to integers
        frame_mapping = {int(k): int(v) for k, v in frame_mapping.items()}

        # Create reverse mapping from original frame to output frame
        for output_num, original_num in frame_mapping.items():
            reverse_mapping[original_num] = output_num

        logger.info(f"Using frame mapping: {frame_mapping}")
        logger.info(f"Reverse mapping: {reverse_mapping}")

    # Check if frame_groups is empty or missing
    if not metadata.get("frame_groups"):
        logger.warning("No frame_groups in metadata, but using grouped format")
        # Create a synthetic group with all frames
        all_frames = sorted([f["frame_number"] for f in metadata["frames"]])
        metadata["frame_groups"] = [
            {
                "event_frame": all_frames[
                    len(all_frames) // 2
                ],  # Middle frame as event
                "event_type": "Event Frame",
                "frames": all_frames,
            }
        ]

    # Process each frame group
    for group_index, group in enumerate(metadata.get("frame_groups", [])):
        try:
            event_frame = group["event_frame"]
            event_type = group["event_type"]
            frames = group["frames"]

            logger.info(
                f"Processing group {group_index+1}: Event {event_frame}, Type: {event_type}, Frames: {frames}"
            )

            # Apply mapping to frame numbers if available
            mapped_frames = []
            for frame_num in frames:
                if frame_num in reverse_mapping:
                    mapped_frames.append(reverse_mapping[frame_num])
                    logger.info(
                        f"Mapped frame {frame_num} to {reverse_mapping[frame_num]}"
                    )
                else:
                    mapped_frames.append(frame_num)

            logger.info(f"After mapping: {mapped_frames}")

            # Determine the row type based on the event type
            row_type = (
                "announcement-row" if "Announcement" in event_type else "scte-row"
            )

            # Create the section
            row_html = f'<div class="timeline-section">\n'
            row_html += f'<div class="timeline-label">{event_type} (Frame {event_frame})</div>\n'
            row_html += f'<div class="timeline-row {row_type}">\n'

            frames_added = 0
            # Add frames to this row
            for i, mapped_frame_num in enumerate(mapped_frames):
                original_frame_num = frames[i]

                # Find frame data for the original frame number
                frame_data = next(
                    (
                        f
                        for f in metadata["frames"]
                        if f["frame_number"] == original_frame_num
                    ),
                    None,
                )

                if not frame_data:
                    logger.warning(f"No metadata for frame {original_frame_num}")
                    # Create default metadata
                    is_event = original_frame_num == event_frame
                    frame_data = {
                        "frame_number": original_frame_num,
                        "type": event_type if is_event else "Padding Frame",
                        "is_padding": not is_event,
                        "padding_for": event_frame if not is_event else None,
                    }

                # Check if the mapped frame number is in our frame files
                if mapped_frame_num in frame_files:
                    try:
                        row_html += generate_frame_html_item(
                            frame_files[mapped_frame_num], frame_data
                        )
                        frames_added += 1
                    except Exception as e:
                        logger.error(
                            f"Error generating HTML for frame {original_frame_num} (mapped to {mapped_frame_num}): {e}"
                        )
                else:
                    logger.warning(
                        f"No image file for mapped frame {mapped_frame_num} (original: {original_frame_num})"
                    )

            row_html += "</div>\n"
            row_html += "</div>\n"

            if frames_added > 0:
                frame_items_html += row_html
                logger.info(f"Added {frames_added} frames to group {group_index+1}")
            else:
                logger.warning(f"No frames were added to group {group_index+1}")
        except KeyError as e:
            logger.error(f"Error processing group {group_index+1}: Missing key {e}")

    if not frame_items_html:
        logger.warning("No frames were added to the HTML, despite having frame groups")
        # As a last resort, try to generate HTML from all available frames
        frame_items_html = """
        <div class="error-message">
            <h2>No frames were found in grouped display</h2>
            <p>The decoder found frames but couldn't organize them into groups. Try using the fallback display:</p>
            <button id="show-fallback" style="margin-top: 20px;">Show All Frames</button>
        </div>
        <div id="fallback-container" style="display:none; margin-top: 30px;">
        """

        # Add all available frames as simple items
        for frame_num in sorted(frame_files.keys()):
            # Get original frame number if we have mapping
            display_num = None
            if frame_mapping:
                # Look up the original frame number
                if str(frame_num) in frame_mapping:
                    display_num = frame_mapping[str(frame_num)]

            # Get frame data from metadata if possible
            if display_num:
                frame_data = next(
                    (f for f in metadata["frames"] if f["frame_number"] == display_num),
                    {"frame_number": display_num, "type": "Frame", "is_padding": False},
                )
            else:
                frame_data = {
                    "frame_number": frame_num,
                    "type": "Frame",
                    "is_padding": False,
                }

            try:
                frame_items_html += generate_frame_html_item(
                    frame_files[frame_num], frame_data
                )
            except Exception as e:
                logger.error(
                    f"Error generating fallback HTML for frame {frame_num}: {e}"
                )

        frame_items_html += "</div>"

        # Add script to show fallback
        frame_items_html += """
        <script>
        document.getElementById('show-fallback').addEventListener('click', function() {
            document.getElementById('fallback-container').style.display = 'flex';
            document.getElementById('fallback-container').style.flexWrap = 'wrap';
            document.getElementById('fallback-container').style.gap = '20px';
            this.style.display = 'none';
        });
        </script>
        """

    return frame_items_html


def generate_legacy_frame_html(
    metadata: Dict[str, Any], frame_files: Dict[int, Path]
) -> str:
    """
    Generate HTML for frames using the legacy format (for backward compatibility).

    Args:
        metadata: Metadata in the legacy format
        frame_files: Dictionary mapping frame numbers to file paths

    Returns:
        str: HTML content for the frame container
    """
    # Group frames by events (ignoring padding frames)
    event_groups = []
    frames = metadata.get("frames", [])

    # First, identify main events (non-padding frames)
    event_frames = []
    for i, frame in enumerate(frames):
        if not frame.get("is_padding", False):
            event_frames.append(
                {"index": i, "data": frame, "type": frame.get("type", "Unknown")}
            )

    # Now group events with their before/after frames
    for event in event_frames:
        event_index = event["index"]
        event_data = event["data"]
        event_type = event["type"]

        # Find preceding and following frames
        before_frames = []
        after_frames = []

        # Get preceding frames
        idx = event_index - 1
        while (
            idx >= 0 and frames[idx].get("is_padding", False) and len(before_frames) < 2
        ):
            before_frames.insert(0, {"index": idx, "data": frames[idx]})
            idx -= 1

        # Get following frames
        idx = event_index + 1
        while (
            idx < len(frames)
            and frames[idx].get("is_padding", False)
            and len(after_frames) < 2
        ):
            after_frames.append({"index": idx, "data": frames[idx]})
            idx += 1

        # Create event group
        event_groups.append(
            {
                "type": (
                    "announcement-row" if "Announcement" in event_type else "scte-row"
                ),
                "label": event_type,
                "frames": before_frames
                + [{"index": event_index, "data": event_data}]
                + after_frames,
            }
        )

    # Create HTML for each timeline group
    frame_items_html = ""

    for group_index, group in enumerate(event_groups):
        row_html = f'<div class="timeline-section">\n'
        row_html += f'<div class="timeline-label">{group["label"]}</div>\n'
        row_html += f'<div class="timeline-row {group["type"]}">\n'

        for frame_info in group["frames"]:
            frame_index = frame_info["index"]
            frame_data = frame_info["data"]
            frame_number = frame_data.get("frame_number", 0)

            if frame_number in frame_files:
                try:
                    row_html += generate_frame_html_item(
                        frame_files[frame_number], frame_data
                    )
                except Exception as e:
                    logger.error(f"Error generating HTML for frame {frame_number}: {e}")

        row_html += "</div>\n"
        row_html += "</div>\n"
        frame_items_html += row_html

    return frame_items_html


def generate_basic_html_viewer(results_dir: Path, input_file: str) -> None:
    """
    Generate a basic HTML viewer without metadata.

    Args:
        results_dir: Directory containing the results
        input_file: Path to the input MXF file
    """
    # Get all frame images
    frame_files = []
    try:
        frame_files = sorted(
            [f for f in results_dir.glob("frames*.jpg")],
            key=lambda x: int(re.match(r"frames(\d+)\.jpg", x.name).group(1)),
        )
    except Exception as e:
        logger.error(f"Error sorting frame files: {e}")
        # Try to get files without sorting
        frame_files = list(results_dir.glob("frames*.jpg"))

    if not frame_files:
        logger.warning(f"No frame files found in {results_dir}")
        return

    # Group frames into events with padding
    timeline_rows = []
    i = 0

    # Process frames in groups of 5 (2 padding, event, 2 padding)
    while i < len(frame_files):
        if i + 4 < len(
            frame_files
        ):  # Need at least 5 frames for a complete row with double padding
            # Alternate between SCTE and Announcement rows
            is_scte = (i // 5) % 2 == 0
            row_type = "scte-row" if is_scte else "announcement-row"
            label = "SCTE Trigger Event" if is_scte else "Announcement Event"

            # In a 5-frame sequence, the middle frame (index 2) is the event
            # 0,1: padding before, 2: event, 3,4: padding after
            frame_types = [
                "Padding Frame",
                "Padding Frame",
                "SCTE Trigger" if is_scte else "Announcement Frame",
                "Padding Frame",
                "Padding Frame",
            ]

            # Create frame data
            frame_data = []
            for j in range(5):
                frame_number = int(
                    re.match(r"frames(\d+)\.jpg", frame_files[i + j].name).group(1)
                )
                frame_data.append(
                    {
                        "file": frame_files[i + j],
                        "type": frame_types[j],
                        "is_padding": j != 2,  # Only the middle frame isn't padding
                        "number": frame_number,
                    }
                )

            # Add the row
            timeline_rows.append(
                {"type": row_type, "label": label, "frames": frame_data}
            )

            i += 5
        else:
            # Add remaining frames as padding
            remaining = []
            while i < len(frame_files):
                frame_number = int(
                    re.match(r"frames(\d+)\.jpg", frame_files[i].name).group(1)
                )
                remaining.append(
                    {
                        "file": frame_files[i],
                        "type": "Padding Frame",
                        "is_padding": True,
                        "number": frame_number,
                    }
                )
                i += 1

            if remaining:
                timeline_rows.append(
                    {
                        "type": "padding-row",
                        "label": "Remaining Frames",
                        "frames": remaining,
                    }
                )

    # Create HTML for each timeline row
    frame_items_html = ""

    for row in timeline_rows:
        row_html = f'<div class="timeline-section">\n'
        row_html += f'<div class="timeline-label">{row["label"]}</div>\n'
        row_html += f'<div class="timeline-row {row["type"]}">\n'

        for frame_info in row["frames"]:
            frame_file = frame_info["file"]
            frame_type = frame_info["type"]
            is_padding = frame_info["is_padding"]
            frame_number = frame_info["number"]

            try:
                frame_data = {
                    "frame_number": frame_number,
                    "type": frame_type,
                    "is_padding": is_padding,
                }

                row_html += generate_frame_html_item(frame_file, frame_data)
            except Exception as e:
                logger.error(f"Error generating HTML for file {frame_file}: {e}")
                # Just skip this file
                continue

        row_html += "</div>\n"
        row_html += "</div>\n"
        frame_items_html += row_html

    # Generate the HTML content
    html_content = HTML_TEMPLATE.format(
        filename=Path(input_file).name,
        total_frames=len(frame_files),
        frame_items=frame_items_html,
    )

    # Write HTML, CSS, and JS files
    try:
        with open(results_dir / "index.html", "w") as f:
            f.write(html_content)

        with open(results_dir / "styles.css", "w") as f:
            f.write(CSS_TEMPLATE)

        with open(results_dir / "viewer.js", "w") as f:
            f.write(JS_TEMPLATE)

        logger.info(f"Basic HTML viewer generated in {results_dir}")
    except Exception as e:
        logger.error(f"Error writing HTML files: {e}")
